"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const plugins_2 = require("hardhat/plugins");
const js_conflux_sdk_1 = require("js-conflux-sdk");
const helpers_1 = require("./helpers");
const scan_cli_1 = require("./scan-cli");
require("./type-extensions");
const TASK_FLATTEN_GET_FLATTENED_SOURCE = "flatten:get-flattened-sources";
config_1.task("verifyCfxContract", "Verify a Conflux contract")
    .addPositionalParam("contractName", "Contract name to verify", undefined, config_1.types.string)
    .addPositionalParam("address", "Base32 address of the smart contract to verify", undefined, config_1.types.string)
    .addOptionalParam("compilerVersion", "Compiler version", undefined, config_1.types.string)
    .addOptionalParam("constructorArgs", "File path to a javascript module that exports the list of arguments.", undefined, config_1.types.inputFile)
    .setAction(verifyConflux);
// @ts-ignore
async function verifyConflux(args, hre) {
    const { contractName, address: contractaddress, compilerVersion, } = args;
    // TODO: support constructor parameters
    // check address
    if (!js_conflux_sdk_1.address.isValidCfxAddress(contractaddress)) {
        throw new plugins_1.NomicLabsHardhatPluginError('hardhat-conflux', 'Invalid Conflux base32 contract address.');
    }
    const addressInfo = js_conflux_sdk_1.address.decodeCfxAddress(contractaddress);
    if (addressInfo.type !== 'contract') {
        throw new plugins_1.NomicLabsHardhatPluginError('hardhat-conflux', 'This is not a contract address.');
    }
    try {
        const compilerversion = compilerVersion ? compilerVersion : hre.userConfig.solidity;
        const artifact = await hre.artifacts.readArtifact(contractName);
        const sourceCode = await hre.run(TASK_FLATTEN_GET_FLATTENED_SOURCE, { files: [artifact.sourceName] });
        const result = await scan_cli_1.verifySourceCode({
            networkId: addressInfo.netId,
            contractaddress,
            sourceCode,
            contractname: contractName,
            compilerversion,
        });
        if (result.code == 0) {
            console.log(`Verify success: ${contractName}`);
        }
        else {
            console.log(`Verify failed: ${result.message}`);
        }
    }
    catch (e) {
        console.log(`Verify failed: ${e.message}`);
    }
}
config_1.extendEnvironment((hre) => {
    hre.ConfluxSDK = plugins_2.lazyObject(() => {
        return {
            Conflux: js_conflux_sdk_1.Conflux,
            format: js_conflux_sdk_1.format,
            Drip: js_conflux_sdk_1.Drip,
            sign: js_conflux_sdk_1.sign,
            PrivateKeyAccount: js_conflux_sdk_1.PrivateKeyAccount,
            address: js_conflux_sdk_1.address,
            PersonalMessage: js_conflux_sdk_1.PersonalMessage,
            Message: js_conflux_sdk_1.Message,
            Transaction: js_conflux_sdk_1.Transaction
        };
    });
    hre.conflux = plugins_2.lazyObject(() => {
        // Create contract instance
        const chainId = hre.network.config.chainId || 0;
        // @ts-ignore
        const url = hre.network.config.url;
        const conflux = new js_conflux_sdk_1.Conflux({
            networkId: chainId,
            url,
        });
        // @ts-ignore
        // Setup accounts
        let accounts = hre.network.config.accounts;
        if (Array.isArray(accounts)) {
            for (let account of accounts) {
                // @ts-ignore
                conflux.wallet.addPrivateKey(account);
            }
        }
        else {
            // TODO: HD wallet
            // throw new NomicLabsHardhatPluginError('hardhat-conflux', 'HD wallet is not supported yet.');
        }
        // @ts-ignore
        conflux.getContractAt = helpers_1.getContractAt.bind(null, hre);
        // @ts-ignore
        conflux.getContractFactory = helpers_1.getContractFactory.bind(null, hre);
        // @ts-ignore
        conflux.getSigners = helpers_1.getSigners.bind(null, hre);
        return conflux;
    });
});
//# sourceMappingURL=index.js.map